article
  p
    | I hate rails. I actually don't like any language or any web framework, and the worst day at work is when you actually have to write code to fix a problem - I rather delete it. But the truth is that there is not much I (we) can do. There will be code.
  p
    | Now when there is code, there are libraries - and the most painfull library to upgrade in the universe is rails. Because with rails there will be another set of libraries, and then when you upgrade rails your older version of some other library stops working - or the opposite: you update some library and rails stop working. Updating the gems of a ruby project's seldom works.
  p
    | The worst part of it is that you'll (most of the times) only know that something broke in runtime. It is like that because it is a dynamic, interpreted language - powerful, expressive, slow to run and to give you the feedback if it actually works. Unit tests are a very good way of getting feedback about your code, but they won't be, in million years, as good as the good ol' compiler. That guy knows its shit.
  p
    | I use to be an Arch Linux user. It was in my early days of college and I just loved it because it was a rolling release distro. That means that, every time there was a new version of a library, Arch Linux would make that the default version of that given library in Arch's repos. Also: Arch Linux users are used to do is system wide updates, mostly because - if you use a rolling release distro it is because, most probably, you have a lot of time to fix and configure it. Bad packages used to come through all the time; and there would be me, recompiling my wireless driver. Painful. But I had my packages up-to-date. Always.
  p
    | I wish we would do more of that with rails/ruby/python/java/code. I often explain the relationship between cost and time when talking about technical debt: if you pay your technical debt everyday you won't acummulate it - so you always have little to pay. If you don't pay it then it will be very costly to do so when you decide to. For instance, say you don't refactor your code/improve your tests for 2 months ond then you decide to fix it or say you actually do that everyday for those same two months. In the best case you would have accumulated the same amount of tech debt for in those two months, but the scenarios are completely different: when you pay it everyday your everyday cost is very low and you also keep your codebase nice and clean; when you pay it once every two months the cost/effort is a lot bigger, and the fact you haven't been cleaning it up makes the code that goes on top of the mess even messier. Best case is the same price but with a lot more effort; worst case you'll pay taxes.
  p
    | I wish more teams would face their library versions as technical debt and decide to pay it (upgrade them) more often. If you ever had to update rails from 2.3 to 3.0 you will know what I am trying to say.
  p
    | So this is what I propose: create a CI stage where you upgrade all your libraries to their latest versions - every night/every 6 hours/every checkin. It is detached from your normal pipeline but it does run everyday. When it runs, it updates all the libraries and run all the tests. It should also report all the failures (if any) at the end. Next day morning somebody spends some time looking at it. If there were libraries that were upgraded and the build was sucessful, you should upgrade them for good in trunk/master/your mainstream of code. If something broke you'll assess how important it is to take the time and fix the code to accomodate that upgrade. Remember - if you don't do it now, it will get a lot more costly and complicated later.
  p
    | Keep it rolling.
