article
  p
    | I hate rails. I actually don't like any language or any web framework, and the worst day at work is when you actually have to write code to fix a problem - I rather delete it. But the truth is that there is not much I (we) can do. There will be code.
  p
    | Now when there is code, there are libraries - and the most painfull library to upgrade in the universe is rails. Because with rails there will be another set of libraries: active[support|record|blablabla]. And then when you upgrade rails your older version of rack stops working - or the opposite: you update rack and rails stop working. Updating a ruby project's Gemfile seldom works, let's face it.
  p
    | It doesn't because it is ruby - it is interpreted. Unit tests are a very good way of getting feedback about your code, but they won't be, in million years, as good as the good ol' compiler. That guy knows its shit.
  p
    | I use to be an Arch Linux user. It was in my early days of college and I just loved it because it was a rolling release distro. That means that, every time there was a new version of a library, Arch Linux would make that the default version of that library in its repos. So other thing that Arch Linux users are used to do is system wide updates. Mostly because if you use a rolling release distro is most probably because you have time to fix the problems that using a rolling release distro causes. Bad packages used to come through all the time and there would be me recompiling my wireless driver. Painful. But nobody had their packages as up-to-date as me.
  p
    | I wish we would do more of that with rails/ruby/python/java/code. I often explain the relationship between cost and time when talking about technical debt: if you pay your technical debt everyday you won't acummulate it - so you always have little to pay. If you don't pay it then it will be very costly to do so when you decide to. For instance, say you don't refactor your code/improve your tests for 2 months ond then you decide to fix it or say you actually do that everyday for those same two months. In the best case you would have accumulated the same amount of tech debt for in those two months, but the scenarios are completely different: when you pay it everyday your everyday cost is very low and you also keep your codebase nice and clean; when you pay it once every two months the cost/effort is a lot bigger, and the fact you haven't been cleaning it up makes the code that goes on top of the mess even messier. Best case is the same price but with a lot more effort; worst case you'll pay taxes.
  p
    | I wish more teams would face their library versions as technical debt and decide to pay it (upgrade them) more often. If you ever had to update rails from 2.3 to 3.0 you will know what I am trying to say.
  p
    | So this is what I propose: create a CI stage where you upgrade all your libraries to their latest versions - every night/every 6 hours/every checkin. It is detached from your normal pipeline but it does run everyday. When it runs, it updates all the libraries and run all the tests. It should also report all the failures (if any) at the end. Next day morning somebody spends some time looking at it. If there were libraries that were upgraded and the build was sucessful, you should upgrade them for good in trunk/master/your mainstream of code. If something broke you'll assess how important it is to take the time and fix the code to accomodate that upgrade. Remember - if you don't do it now, it will get a lot more costly and complicated later.
  p
    | Keep it rolling.
