article
  p
    | I hate rails [in this moment]. I actually don't like any language or any web framework, and the worst day at work is when you actually have to write code to fix a problem - I rather delete it. But the truth is that there is not much I (we) can do. There will be code.
  p
    | Now when there is code, there are libraries - and the most painfull library to upgrade in the universe is rails. Because with rails there will be another set of libraries, and then when you upgrade rails your older version of some other library stops working - or the opposite: you update some library and rails stops working. Updating the gems of a ruby project seldom works.
  p
    | The worst part of it is that you'll (most of the times) only know that something is broken in runtime. That's what happens with our beautiful, dynamic, interpreted languages - powerful, expressive, slow to run and to give you the feedback that it actually works. Unit tests are a very good way of getting feedback about your code, but they won't be, in million years, as reliable and fast as the good ol' compiler. That guy knows its shit.
  p
    | I used to be an 
    a href="https://www.archlinux.org/" Arch Linux
    |  user. It was in my early days of college and I just loved it because it is a 
    a href="http://en.wikipedia.org/wiki/Rolling_release" rolling release distro
    |. It means that, every time there is a new version of a package, Arch Linux will make that the default version for that given package in its repos. Also: Arch Linux users often do system wide updates, mostly because they are college students and have a lot of time to fix and configure it. Bad packages will come through all the time; and then there will be you, recompiling your wireless driver or having to rollback a readline change. Painful. However, once you are done, you will have all your packages up-to-date. And that is a good thing.
  p
    | I wish we would do more of that with rails/ruby/python/java/code. I often explain the relationship between cost and time when dealing with 
    a href="http://martinfowler.com/bliki/TechnicalDebt.html" technical debt
    |: if you pay your technical debt everyday then you won't accumulate it - so you always have little to pay. If you don't pay it often then the cost of paying it will increase and it will be very painful to fix it when you decide to do so. For instance, say you don't refactor your code/improve your tests for 2 months and then you decide to fix it. Other scenario: you pay tech debt everyday (for those same two months). When comparing both scenarios, in the best case you would have accumulated the same amount of tech debt in those two months and spend the same time fixing it. Such a lovely 'best case'. Truth is: when you pay it everyday your [everyday] cost is very low - and you also keep your codebase clean and extensible; when you pay it once every two months the cost/effort will be a lot bigger, and the fact that you haven't been cleaning it up makes the code that goes on top of the mess to be even messier. You pay taxes.
  hr
  p
    | We know we should keep our tech debt low and manageable. I wish we would to the same when dealing with the libraries we use in our codebase; I wish we would face our library versions as technical debt and decide to upgrade them more often. If you ever had to update rails from 2.3 to 3.0 you will know what I am trying to say.
  p
    | So here's an idea: why not have a pipeline/stage in your 
    a href="http://martinfowler.com/articles/continuousIntegration.html" Continuos Integration
    |  server where you upgrade all your libraries to their latest versions - every night/every 6 hours/every checkin - and run your build? Something like this:
    ul
      li
        | Your new stage/pipeline is detached from your normal pipeline (but it runs oftens).
      li
        | When it runs, it updates all the libraries and runs all the tests. 
      li
        | It should report the library changes at the end of it.
      li
        | If there are failures, somebody should spend some time looking at it and assess how risky that upgrade would be. The ideal situation is that it won't be that hard to fix it, so it is worth a try.
      li
        | If there were no failures, you should upgrade your libraries for once and for good in trunk/master/your main stream of code. Extra points given for an automatic pull request. 
  p
    | Remember that if you don't do it now, it will get a lot more costly and complicated later. Pay it often, avoid taxes.
  p
    | And keep on rolling.
